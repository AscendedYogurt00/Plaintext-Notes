 [2020-06-23]
General
    // Prints 5 to the console
    console.log(5);

    /*
    This is all commented 
    console.log(10);
    None of this is going to run!
    console.log(99);
    */
    console.log(5);

    console.log('JavaScript');

    running a file from the command line

        $ node filename.js

    String Interpolation
        var myName = 'Alex';
        var myCity = 'New York';
        console.log(`My name is ${myName}. My favorite city is ${myCity}`);

Conditionals 

    If Else
        let mood = 'sleepy';
        let tirednessLevel = 6;

        if (mood === 'sleepy' && tirednessLevel > 8) {
        console.log('time to sleep')
        }
        else {
        console.log('not bed time yet')
        }


    Truthy and Fasly Assignments 

        let writingUtensil = tool || 'pen';


    Ternary Operator       

        Basically an if else statement shortened 

        let isLocked = false;

        isLocked ? console.log('You will need a key to open the door.') 
        : console.log('You will not need a key to open the door.');
        
        favoritePhrase === 'Love That!' ? console.log('I love that!') 
        : console.log("I don't love that!")

    Else If

        let groceryItem = 'papaya';

        if (groceryItem === 'tomato') {
        console.log('Tomatoes are $0.49');
        } else if (groceryItem === 'papaya'){
        console.log('Papayas are $1.29');
        } else {
        console.log('Invalid item');
        }

Switch Keyword

    let groceryItem = 'papaya';

    switch (groceryItem) {
    case 'tomato':
        console.log('Tomatoes are $0.49');
        break;
    case 'lime':
        console.log('Limes are $1.49');
        break;
    case 'papaya':
        console.log('Papayas are $1.29');
        break;
    default:
        console.log('Invalid item');
        break;
    }

Functions

    function greetWorld() {
    console.log('Hello, World!');
    }

    Parameters
        function sayThanks(name) {
        console.log('Thank you for your purchase ' + name + '! We appreciate your business.');
        }

        sayThanks('Cole')

    Default Parameters

        function makeShoppingList(item1 = 'milk', item2 = 'bread', item3 = 'eggs'){
        console.log(`Remember to buy ${item1}`);
        console.log(`Remember to buy ${item2}`);
        console.log(`Remember to buy ${item3}`);
        }


    Function Expressions 

        const plantNeedsWater = function(day, plantNeedsWater){
        if(day === 'Wednesday'){
            return true;
        }
        else {
            return false;
          }
        }

        console.log(plantNeedsWater('Tuesday'));       

    Arrow Functions

       ES6 introduced arrow function syntax, a shorter way to write functions by using the special “fat arrow” () => notation.

        Arrow functions remove the need to type out the keyword function every time you need to create a function. 
        Instead, you first include the parameters inside the ( ) 
        and then add an arrow => that points to the function body surrounded in { } like this:

            const rectangleArea = (width, height) => {
            let area = width * height;
            return area;
            };

    Concise Body Arrow Functions

        const squareNum = (num) => {
        return num * num;
        };     

        turns into 

        const squareNum = num => num * num;

        const plantNeedsWater = (day) => {
        return day === 'Wednesday' ? true : false;
        };

        turns into 

        const plantNeedsWater = day => day === 'Wednesday' ? true : false;

    Functions as Data

        const checkThatTwoPlusTwoEqualsFourAMillionTimes = () => {
        for(let i = 1; i <= 1000000; i++) {
            if ( (2 + 2) != 4) {
            console.log('Something has gone very wrong :( ');
            }
        }
        }

        // Write your code below
        const is2p2 = checkThatTwoPlusTwoEqualsFourAMillionTimes;

        is2p2();

        console.log(is2p2.name);

    

Arrays

    let concepts = ['creating arrays', 'array structures', 'array manipulation'];

    const hello = 'Hello World';
    console.log(hello[6]);
    // Output: W

    const objectives = ['Learn a new languages', 'Read 52 books', 'Run a marathon'];
    console.log(objectives.length)
    // Output: 3



    .push() 

        adds items to the end of an array

    .pop() 

        removes an item from the end of the array

    .shift()  

        moves the array down and removes any item that moves off the list
        
    .unshift() 

        adds the parameter to the beginning of the list

    .slice()

        cuts the items out of array and returns those values
        does not effect the original array 

        console.log(groceryList.slice(1,4));

    .indedOf()

    Nested Arrays 

        const nestedArr = [[1], [2, 3]];
        console.log(nestedArr[1]); // Output: [2, 3]

        const numberClusters = [[1,2],[3,4],[5,6]];
        console.log(numberClusters[2][1]); // Output 6


Loops

    For Loop

        for (let counter = 0; counter < 4; counter++) {
            console.log(counter);
        }
        
    Nested Loops

        const bobsFollowers = ['Steve', 'Matt', 'Ian', 'Michael'];
        const tinasFollowers = ['Matt', 'Michael', 'John'];
        const mutualFollowers = [];

        for(let i = 0; i < bobsFollowers.length; i++){
        for(let j = 0; j < tinasFollowers.length; j++){
            if(bobsFollowers[i] === tinasFollowers[j]){
            mutualFollowers.push(bobsFollowers[i]);
            }
         } 
        }

    While Loop 

        let counterTwo = 1;
        while (counterTwo < 4) {
        console.log(counterTwo);
        counterTwo++;
        }

    Do While Loops

        let countString = '';
        let i = 0;

        do {
        countString = countString + i;
        i++;
        } while (i < 5);

        console.log(countString);

    Break Statements 

        JavaScript supports break statements 

Iterators 
    .forEach()

        Aptly named, .forEach() will execute the same code for each element of an array.

        const artists = ['Picasso', 'Kahlo', 'Matisse', 'Utamaro'];
        artists.forEach(artist => {
        console.log(artist + ' is one of my favorite artists.');
        });


        const fruits = ['mango', 'papaya', 'pineapple', 'apple'];
        fruits.forEach(fruitsItem => console.log('I want to eat a ' + fruitsItem));

    .map()
        
        When .map() is called on an array, 
        it takes an argument of a callback function and returns a new array! 
        
        const numbers = [1, 2, 3, 4, 5];
        const squareNumbers = numbers.map(number => {
        return number * number;
        });

    .filter()

        Another useful iterator method is .filter(). Like .map(), .filter() returns a new array. 
        However, .filter() returns an array of elements after filtering out certain elements from the original array. 


        const things = ['desk', 'chair', 5, 'backpack', 3.14, 100];
        const onlyNumbers = things.filter(thing => {
        return typeof thing === 'number';
        });


        const randomNumbers = [375, 200, 3.14, 7, 13, 852];
        const smallNumbers = randomNumbers.filter(thing => {
        return thing < 250;
        });


        const favoriteWords = ['nostalgia', 'hyperbole', 'fervent', 'esoteric', 'serene'];
        const longFavoriteWords = favoriteWords.filter(word => {
        return word.length > 7;
        });


    .findIndex() 

        returns the index of the first element that evaluates to true in the callback function

        const jumbledNums = [123, 25, 78, 5, 9]; 
        const lessThanTen = jumbledNums.findIndex(num => {
        return num < 10;
        });


        const animals = ['hippo', 'tiger', 'lion', 'seal', 'cheetah', 'monkey', 'salamander', 'elephant'];
        const foundAnimal = animals.findIndex(animal => {return animal === 'elephant'});
        const startsWithS = animals.findIndex(animal => {return animal[0] === 's'})


    .reduce() 

        returns a single value after iterating through the elements of the array. Reducing it

        const numbers = [1, 2, 4, 10];
        const summedNums = numbers.reduce((accumulator, currentValue) => {
        return accumulator + currentValue
        })
        console.log(summedNums) // Output: 17

        const newNumbers = [1, 3, 5, 7];
        const newSum = newNumbers.reduce((accumulator, currentValue) => {
        return accumulator + currentValue;
        }, 10 /* second argument acts as an initial value for accumulator */);
        console.log(newSum)


    .some() 

        The some() method tests whether at least one element in the array passes the test implemented by the provided function. 
        It returns a Boolean value.


    .every()

        The every() method tests whether all elements in the array pass the test implemented by the provided function. 
        It returns a Boolean value.

    Summary Of Methods

        const cities = ['Orlando', 'Dubai', 'Edinburgh', 'Chennai', 'Accra', 'Denver', 'Eskisehir', 'Medellin', 'Yokohama'];

        const nums = [1, 50, 75, 200, 350, 525, 1000];

        //  Choose a method that will return undefined
        cities.forEach(city => console.log('Have you visited ' + city + '?'));

        // Choose a method that will return a new array
        const longCities = cities.filter(city => city.length > 7);

        // Choose a method that will return a single value
        const word = cities.reduce((acc, currVal) => {
        return acc + currVal[0]
        }, "C");

        console.log(word)

        // Choose a method that will return a new array
        const smallerNums = nums.map(num => num - 5);

        // Choose a method that will return a boolean value
        nums.some(num => num < 0);


Objects 
    
    Syntax 

        let fasterShip = {
        'Fuel Type': 'Turbo Fuel',
        color: 'silver'
        };

    Access 

        let spaceship = {
        homePlanet: 'Earth',
        color: 'silver',
        'Fuel Type': 'Turbo Fuel',
        numCrew: 5,
        flightPath: ['Venus', 'Mars', 'Saturn']
        };

        const crewCount = spaceship.numCrew;
        const planetArray = spaceship.flightPath;

    Bracket Notation 

        let spaceship = {
        'Fuel Type': 'Turbo Fuel',
        'Active Duty': true,
        homePlanet: 'Earth',
        numCrew: 5
        };
        spaceship['Active Duty'];   // Returns true
        spaceship['Fuel Type'];   // Returns  'Turbo Fuel'
        spaceship['numCrew'];   // Returns 5
        spaceship['!!!!!!!!!!!!!!!'];   // Returns undefined

        returnAnyProp(spaceship, 'homePlanet'); // Returns 'Earth'


        let spaceship = {
        'Fuel Type' : 'Turbo Fuel',
        homePlanet : 'Earth',
        color: 'silver',
        'Secret Mission' : 'Discover life outside of Earth.'
        };

        spaceship.color = 'glorious gold';
        spaceship.numEngines = 4;
        delete spaceship['Secret Mission'];


    Methods 

        const alienShip = {
        invade () { 
            console.log('Hello! We have come to dominate your planet. Instead of Earth, it shall be called New Xaculon.')
        }
        };

        alienShip.invade();


        let retreatMessage = 'We no longer wish to conquer your planet. It is full of dogs, which we do not care for.';
        let alienShip = {
        retreat ()  {
            console.log(retreatMessage);
        },
        takeOff () {
            console.log('Spim... Borp... Glix... Blastoff!')
        }
        };
        alienShip.retreat();
        alienShip.takeOff();

    Nested Objects 

        let spaceship = {
        passengers: [{name: 'Dog'}], 
        telescope: {
            yearBuilt: 2018,
            model: "91031-XLT",
            focalLength: 2032 
        },
        crew: {
            captain: { 
            name: 'Sandra', 
            degree: 'Computer Engineering', 
            encourageTeam() { console.log('We got this!') },
            'favorite foods': ['cookies', 'cakes', 'candy', 'spinach'] }
        },
        engine: {
            model: "Nimbus2000"
        },
        nanoelectronics: {
            computer: {
            terabytes: 100,
            monitors: "HD"
            },
            'back-up': {
            battery: "Lithium",
            terabytes: 50
            }
        }
        }; 

        let capFave = spaceship.crew.captain['favorite foods'][0];
        let firstPassenger = spaceship.passengers[0];

    Pass By Refrence 

        pass a variable assigned to an object into a function as an argument, 
        the computer interprets the parameter name as pointing to the space in 
        memory holding that object. As a result, functions which change object 
        properties actually mutate the object permanently 
        (even when the object is assigned to a const variable).

        let spaceship = {
        'Fuel Type' : 'Turbo Fuel',
        homePlanet : 'Earth'
        };

        let greenEnergy = obj => {
        obj['Fuel Type'] = 'avocado oil';
        }

        let remotelyDisable = obj => {
        obj.disabled = true;
        }

        greenEnergy(spaceship);
        remotelyDisable(spaceship);
        console.log(spaceship)

    Looping Through Objects

        For In statements 

            for (let crewMember in spaceship.crew) {
            console.log(`${crewMember}: ${spaceship.crew[crewMember].name}`)
            };

            let spaceship = {
                crew: {
                captain: { 
                    name: 'Lily', 
                    degree: 'Computer Engineering', 
                    cheerTeam() { console.log('You got this!') } 
                    },
                'chief officer': { 
                    name: 'Dan', 
                    degree: 'Aerospace Engineering', 
                    agree() { console.log('I agree, captain!') } 
                    },
                medic: { 
                    name: 'Clementine', 
                    degree: 'Physics', 
                    announce() { console.log(`Jets on!`) } },
                translator: {
                    name: 'Shauna', 
                    degree: 'Conservation Science', 
                    powerFuel() { console.log('The tank is full!') } 
                    }
                }
            }; 

            for (let crewMember in spaceship.crew){
            console.log(crewMember + ': ' + spaceship.crew[crewMember].name);
            };

            for (let crewMember in spaceship.crew){
            console.log(spaceship.crew[crewMember].name + ': ' + spaceship.crew[crewMember].degree);
            };

Advanced Objects

    This Keyword

        The this keyword references the calling object 
        which provides access to the calling object’s properties.

        The key takeaway from the example above is to avoid using 
        arrow functions when using this in a method!

        const robot = {
        model: '1E78V2',
        energyLevel: 100,
        provideInfo () {
            return `I am ${this.model} and my current energy level is ${this.energyLevel}.`
        }
        };
        console.log(robot.provideInfo());


        const robot = {
        energyLevel: 100,
        checkEnergy () {
            console.log(`Energy is currently at ${this.energyLevel}%.`)
        }
        }
        robot.checkEnergy();

    Privacy 

        One common convention is to place an underscore _ before the name of a property 
        to mean that the property should not be altered

    Getters 

        get and return internal properties of the object 

            const robot = {
            _model: '1E78V2',
            _energyLevel: 100,
            get energyLevel(){
                if(typeof this._energyLevel === 'number'){
                return 'My current energy level is ' + this._energyLevel ;
                }
                else {
                return 'System malfunction: cannot retrieve energy level';
                }

            }
            };
            console.log(robot.energyLevel)
        

    Setters 

        reassign values of existing properties within an object

        const robot = {
        _model: '1E78V2',
        _energyLevel: 100,
        _numOfSensors: 15,
        get numOfSensors(){
            if(typeof this._numOfSensors === 'number'){
                return this._numOfSensors;
            } else {
                return 'Sensors are currently down.'
                }
            },
        set numOfSensors (num){
            if(typeof num === 'number' && num >= 0){
            this._numOfSensors = num;
            }
            else {
            console.log('Pass in a number that is greater than or equal to 0');
            }
        }
        };
        robot.numOfSensors = 100;

    Factory Functions 

        A factory function is a function that returns an object 
        and can be reused to make multiple object instances

        const monsterFactory = (name, age, energySource, catchPhrase) => {
        return { 
            name: name,
            age: age, 
            energySource: energySource,
            scare() {
            console.log(catchPhrase);
            } 
        }
        };
        const ghost = monsterFactory('Ghouly', 251, 'ectoplasm', 'BOO!');
        ghost.scare(); // 'BOO!'


    Property Value Shorthand

        const monsterFactory = (name, age) => {
        return { 
            name,
            age 
        }
        };

    Destructured Assignment

        const robot = {
        model: '1E78V2',
        energyLevel: 100,
        functionality: {
            beep() {
            console.log('Beep Boop');
            },
            fireLaser() {
            console.log('Pew Pew');
            },
        }
        };

        const { functionality } = robot;  // Here is the Destructed Assignment 

        functionality.beep();


    Built-in Object Methods

        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object#Methods

        .valueOf()
        .hasOwnProperty()

        const robot = {
            model: 'SAL-1000',
        mobile: true,
        sentient: false,
        armor: 'Steel-plated',
        energyLevel: 75
        };

        const robotKeys = Object.keys(robot);
        console.log(robotKeys);

        const robotEntries = Object.entries(robot);
        console.log(robotEntries);

        const newRobot = Object.assign({laserBlaster: true, voiceRecognition: true}, robot);
        console.log(newRobot);


Classes

    Structure 

        class Dog {
        constructor(name) {
            this._name = name;
            this._behavior = 0;
        }

        get name() {
            return this._name;
        }
        get behavior() {
            return this._behavior;
        }   

        incrementBehavior() {
            this._behavior ++;
         }
        }


    Constructor 

        class Surgeon {
        constructor(name, department){
            this.name = name;
            this.department = department;
            }
        }

    Instance 

        An instance is an object that contains the property names and methods of a class, 
        but with unique property values

        const halley = new Dog('Halley');  // Creates a new instance of the Dog class

    Inheritance 

        With inheritance, you can create a parent class (also known as a superclass) with properties 
        and methods that multiple child classes (also known as subclasses) share. 
        The child classes inherit the properties and methods from their parent class.

        class HospitalEmployee {
        constructor(name) {
            this._name = name;
            this._remainingVacationDays = 20;
        }
        
        get name() {
            return this._name;
        }
        
        get remainingVacationDays() {
            return this._remainingVacationDays;
        }
        
        takeVacationDays(daysOff) {
            this._remainingVacationDays -= daysOff;
        }
        }

        class Nurse extends HospitalEmployee {
        constructor(name, certifications) {
            super(name);
            this._certifications = certifications;
        } 
        get certifications (){
            return this._certifications;
        }
        addCertification (newCertification){
            this._certifications.push(newCertification);
        }
        }

        const nurseOlynyk = new Nurse('Olynyk', ['Trauma','Pediatrics']);
        nurseOlynyk.takeVacationDays(5);
        console.log(nurseOlynyk.remainingVacationDays);
        nurseOlynyk.addCertification('Genetics');
        console.log(nurseOlynyk.certifications);
            
    
    Static Methods

        Sometimes you will want a class to have methods that aren’t available in individual instances, 
        but that you can call directly from the class.

        Take the Date class, for example — you can both create Date instances to represent whatever date you want, and call static methods, like Date.now() which returns the current date, directly from the class. The .now() method is static, so you can call it directly from the class, but not from an instance of the class.

        class Animal {
        constructor(name) {
            this._name = name;
            this._behavior = 0;
        }

        static generateName() {
            const names = ['Angel', 'Spike', 'Buffy', 'Willow', 'Tara'];
            const randomNumber = Math.floor(Math.random()*5);
            return names[randomNumber];
        }
        }
        console.log(Animal.generateName()); // returns a name

Browser Compatibility and Transpilation

    caniuse.com — A website that provides data on web browser compatibility for HTML, CSS, and JavaScript features. You will learn how to use it to look up ES6 feature support.

    Babel — A Javascript library that you can use to convert new, unsupported JavaScript (ES6), into an older version (ES5) that is recognized by most modern browsers.

        $ npm install babel-cli    
        $ npm install babel-preset-env
        $ npm run build
        // not sure why these are here 

    Creating a JavaScript project that transpiles code when you run npm run build from the root directory of a JavaScript project.

        Installing Node Packet manager - https://docs.npmjs.com/getting-started/what-is-npm

        $ npm init   // creates an package.json

        $ npm install babel-cli -D
        $ npm install babel-preset-env -D

        in the root direcory create a .bablerc file
        $ touch .babelrc 

        Add: 
            {
            "presets": ["env"]
            }
        to the .babelrc file to specify we are translating from ES6

        Inside of the package.json file, there is a property named "scripts" that holds an object for specifying command line shortcuts.

        In the code above, the "scripts" property contains an object with one property called "test". Below the "test" property, we will add a script that runs Babel like this:
            ...
            "scripts": {
            "test": "echo \"Error: no test specified\" && exit 1",
            "build": "babel src -d lib"
            }

        $ npm run build
            Babel writes the ES5 code to a file named main.js (it’s always the same name as the original file), inside of a folder called lib
            The npm run build command will transpile all JavaScript files inside of the src folder



Intermediate JavaScript Modules

    https://nodejs.org/en/about/

    JavaScript modules are reusable pieces of code that can be exported from one program and imported for use in another program.

    The pattern we use to export modules is thus:

        1.  Create an object to represent the module.
        2.  Add properties or methods to the module object.
        3.  Export the module with module.exports.

        // airplane.js
        let Airplane = {}
        Airplane.myAirplane = 'StarJet';
        module.exports = Airplane;
    
    require()

        To make use of the exported module and the behavior we define within it, we import the module into another file. In Node.js, use the require() function to import modules.

        Import the module with require() and assign it to a local variable.
        Use the module and its properties within a program.

            // missionControl.js
            const Airplane = require('./1-airplane.js')

            const displayAirplane = () => {
            console.log(Airplane.myAirplane);
            }
            displayAirplane();
        
    module.exports

        // 2-airplane.js
        module.exports = {
        myAirplane: "CloudJet", 
        displayAirplane: function() {
            return this.myAirplane;
        }
        };

        // 2-missionControl.js
        module.exports = {
        myAirplane: "CloudJet", 
        displayAirplane: function() {
            return this.myAirplane;
        }
        };

    export default 

        const Airplane = {
        availableAirplanes: [{name: 'AeroJet', fuelCapacity: 800}, {name: 'SkyJet', fuelCapacity: 500}]
        }
        export default Airplane;    // Here is export default

    import 

        import Airplane from './airplane';

        const displayFuelCapacity = () => {
        Airplane.availableAirplanes.forEach(function (element) {
            console.log('Fuel capacity of ' + element.name + ': ' + element.fuelCapacity);
        });


        }
        console.log(displayFuelCapacity());

    
    Named Exports 

        // airplane.js
        let availableAirplanes = [{name: 'AeroJet', fuelCapacity: 800, availableStaff: ['pilots', 'flightAttendants', 'engineers', 'medicalAssistance', 'SensorOperators']}, {name: 'SkyJet', fuelCapacity: 500, availableStaff: ['pilots', 'flightAttendants']}]

        let flightRequirements = {
        requiredStaff: 4

        }
        const meetsStaffRequirements = (availableStaff, requiredStaff) => {
            if(availableStaff.length >= requiredStaff){
            return true;
            }
            else {
            return false;
            }
        }
        export {availableAirplanes, flightRequirements, meetsStaffRequirements};


    Named Imports

        // missionControl.js
        import  { availableAirplanes, flightRequirements, meetsStaffRequirements } from './airplane';   // new import statement 

        const displayFuelCapacity = () => {
        availableAirplanes.forEach(function (element) {
            console.log('Fuel capacity of ' + element.name + ': ' + element.fuelCapacity);
        });
        }
        console.log(displayFuelCapacity());

        function displayStaffStatus(){
        availableAirplanes.forEach(function (element){
            console.log(element.name + ' meets staff requirements: ' + meetsStaffRequirements(element.availableStaff, flightRequirements.requiredStaff) );
            
        });
        }

        displayStaffStatus();

    Export Named Exports

        Named exports are also distinct in that they can be exported as soon as they are declared, by placing the keyword export in front of variable declarations.

        export let specialty = '';
        export function isVegetarian() {
        }; 
        function isLowSodium() {
        }; 

    Import Named Imports

        import { specialty, isVegetarian } from 'menu';

    Export as

        let specialty = '';
        let isVegetarian = function() {
        }; 
        let isLowSodium = function() {
        }; 

        export { specialty as chefsSpecial, isVegetarian as isVeg, isLowSodium };

            1.  The as keyword allows us to give a variable name an alias as demonstrated in specialty as chefsSpecial and isVegetarian as isVeg.
            2.  Since we did not give isLowSodium an alias, it will maintain its original name.

    Import as

        import { chefsSpecial, isVeg } from './menu';

        Another way of using aliases is to import the entire module as an alias:
            import * as Carte from './menu';

            Carte.chefsSpecial;
            Carte.isVeg();
            Carte.isLowSodium(); 

    You can combine different export statements and import statements 


Prmoise and Asyasynchronous Programming 

    const executorFunction = (resolve, reject) => { };
    const myFirstPromise = new Promise(executorFunction);

    The Promise constructor method takes a function parameter called the executor function which runs automatically when the constructor is called. The executor function generally starts an asynchronous operation and dictates how the promise should be settled.

    const executorFunction = (resolve, reject) => {
    if (someCondition) {
        resolve('I resolved!');
    } else {
        reject('I rejected!'); 
    }
    }
    const myFirstPromise = new Promise(executorFunction);


    Making a Promise Object

        const inventory = {
        sunglasses: 0,
        pants: 1088,
        bags: 1344
        };

        function myExecutor(resolve, reject){
        if(inventory.sunglasses > 0){
            resolve('Sunglasses order processed.');
        }
        else{
            reject('That item is sold out.');
        }
        }

        function orderSunglasses () {
        return new Promise(myExecutor);
        }
        const orderPromise = orderSunglasses();

        console.log(orderPromise);


    The Node setTimeout() Function


        const returnPromiseFunction = () => {
        return new Promise((resolve, reject) => {
            setTimeout(( ) => {resolve('I resolved!')}, 1000);
        });
        };

        const prom = returnPromiseFunction();

        /*****************************************************************************/

        console.log("This is the first line of code in app.js.");
        // Keep the line above as the first line of code
        // Write your code here:

        function usingSTO(){
        console.log('1');
        }

        setTimeout(usingSTO, 2000);

        // Keep the line below as the last line of code:
        console.log("This is the last line of code in app.js.");


    The onFulfilled and onRejected Functions

        let prom = new Promise((resolve, reject) => {
        let num = Math.random();
        if (num < .5 ){
            resolve('Yay!');
        } else {
            reject('Ohhh noooo!');
        }
        });

        const handleSuccess = (resolvedValue) => {
        console.log(resolvedValue); // onFulfilled 
        };

        const handleFailure = (rejectionReason) => {
        console.log(rejectionReason); // onRejected 
        };

        prom.then(handleSuccess, handleFailure);     // uses .then() to print which ever value is resolved/rejected

        /*****************************************************************************/   

    Using catch() with Promises

        Allows for more readability, is is just the second paramater of .then()

        prom
        .then((resolvedValue) => {
            console.log(resolvedValue);
        })
        .catch((rejectionReason) => {
            console.log(rejectionReason);
        });


    Chaining Multiple Promises

        firstPromiseFunction()
        .then((firstResolveVal) => {
        return secondPromiseFunction(firstResolveVal);
        })
        .then((secondResolveVal) => {
        console.log(secondResolveVal);
        });

    Avoiding Common Mistakes

        Mistake 1: Nesting promises instead of chaining them.

        Mistake 2: Forgetting to return a promise.

            checkInventory(order)
                .then((resolvedValueArray) => {
                return processPayment(resolvedValueArray)
                })
                .then((resolvedValueArray) => {
                    return shipOrder(resolvedValueArray)
                })
                .then((successMessage) => {
                    console.log(successMessage);
                });


    Using Promise.all()

        Promise.all() accepts an array of promises as its argument and returns a single promise. That single promise will settle in one of two ways:

        1. If every promise in the argument array resolves, the single promise returned from Promise.all() will resolve with an array containing the resolve value from each promise in the argument array.

        2. If any promise from the argument array rejects, the single promise returned from Promise.all() will immediately reject with the reason that promise rejected. This behavior is sometimes referred to as failing fast.
                
        let myPromises = Promise.all([returnsPromOne(), returnsPromTwo(), returnsPromThree()]);
        myPromises
        .then((arrayOfValues) => {
            console.log(arrayOfValues);
        })
        .catch((rejectionReason) => {
            console.log(rejectionReason);
        });



Async Await

    ES8 syntax for writing asynchronous functions that read like synchronous code!

    The async keyword is used to write functions that handle asynchronous actions. We wrap our asynchronous logic inside a function prepended with the async keyword. Then, we invoke that function.

        async function myFunc() {
        // Function body here
        };

        myFunc();

    We’ll be using async function declarations throughout this lesson, but we can also create async function expressions:

        const myFunc = async () => {
        // Function body here
        };

        myFunc();

    async functions always return a promise. This means we can use traditional promise syntax, like .then() and .catch with our async functions. An async function will return in one of three ways:

        If there’s nothing returned from the function, it will return a promise with a resolved value of undefined.
        If there’s a non-promise value returned from the function, it will return a promise resolved to that value.
        If a promise is returned from the function, it will simply return that promise


    async function withAsync (num){
        if (num === 0){
        return 'zero';
        } else {
        return 'not zero';
        }
    }
    withAsync(100)
    .then((resolveValue) => {
    console.log(` withAsync(100) returned a promise which resolved to: ${resolveValue}.`);
    })


    The await Operator

        The await keyword can only be used inside an async function. await is an operator: it returns the resolved value of a promise. Since promises resolve in an indeterminate amount of time, await halts, or pauses, the execution of our async function until a given promise is resolved

        async function asyncFuncExample(){
        let resolvedValue = await myPromise();
        console.log(resolvedValue);
        }

        asyncFuncExample(); // Prints: I am resolved now!


    Handling Dependent Promises


        const {shopForBeans, soakTheBeans, cookTheBeans} = require('./library.js');

        // Write your code below:
        async function makeBeans(){
        let type = await shopForBeans();
        let isSoft = await soakTheBeans(type);
        let dinner = await cookTheBeans(isSoft);
        console.log(dinner);
        }
        makeBeans();

    
    Handling Errors

        try...catch 

            async function usingTryCatch() {
            try {
            let resolveValue = await asyncFunction('thing that will fail');
            let secondValue = await secondAsyncFunction(resolveValue);
            } catch (err) {
            // Catches any errors in the try block
            console.log(err);
            }
            }
            usingTryCatch();

        or .catch because async uses promises 

            async function usingPromiseCatch() {
            let resolveValue = await asyncFunction('thing that will fail');
            }

            let rejectedPromise = usingPromiseCatch();
            rejectedPromise.catch((rejectValue) => {
            console.log(rejectValue);
            })

    Handling Independent Promises

        // waits for the first promise to finish to start on the next one
        async function waiting() {
        const firstValue = await firstAsyncThing();
        const secondValue = await secondAsyncThing();
        console.log(firstValue, secondValue);
        }
        // starts both promises and waits on both while they run simultaniously 
        async function concurrent() {
        const firstPromise = firstAsyncThing();
        const secondPromise = secondAsyncThing();
        console.log(await firstPromise, await secondPromise);
        }


    Await Promise.all()

        let {cookBeans, steamBroccoli, cookRice, bakeChicken} = require('./library.js')
        async function serveDinnerAgain(){
        let foodArray = await Promise.all([steamBroccoli(), cookRice(), bakeChicken(), cookBeans()]);
        console.log(`Dinner is served. We're having ${foodArray[0]}, ${foodArray[1]}, ${foodArray[2]}, and ${foodArray[3]}.`)
        }
        serveDinnerAgain();

HTTP Requests 

    XHR GET Requests

        // Creates a new object
        const xhr = new XMLHttpRequest;
        const url = 'https://api-to-call.com/endpoint';
        
        // Handels response 
        xhr.responseType = 'json';
        xhr.onreadystatechange  = () => {
        if (xhr.readyState === XMLHttpRequest.DONE) {
            return xhr.response;
        }
        }

        // Opens requests and sends object
        xhr.open('GET', url);
        xhr.send();

        https://www.datamuse.com/api/

            // Information to reach API
            const url = 'https://api.datamuse.com/words?';
            const queryParams = 'rel_rhy=';
            // Selecting page elements
            const inputField = document.querySelector('#input');
            const submit = document.querySelector('#submit');
            const responseField = document.querySelector('#responseField');

            // AJAX function
            const getSuggestions = () => {
            const wordQuery = inputField.value;
            const endpoint = url + queryParams + wordQuery;
            const xhr = new XMLHttpRequest();
            xhr.responseType = 'json';
            xhr.onreadystatechange  = () => {
                if (xhr.readyState === XMLHttpRequest.DONE) {
            renderResponse(xhr.response)    }
                xhr.open('GET', endpoint);
                xhr.send();
            }
            }

            // Clear previous results and display results to webpage
            const displaySuggestions = (event) => {
            event.preventDefault();
            while(responseField.firstChild){
                responseField.removeChild(responseField.firstChild);
            };
            getSuggestions();
            }

            submit.addEventListener('click', displaySuggestions);


        Query String 

        A query string is separated from the URL using a ? character. After ?, you can then create a parameter which is a key value pair joined by a =. Examine the example below:

            'https://api.datamuse.com/words?key=value'

        If you want to add an additional parameter you will have to use the & character to separate your parameters. Like so:

            'https://api.datamuse.com/words?key=value&anotherKey=anotherValue'



    XHR POST Requests - https://app.rebrandly.com/account/api-keys

        The major difference between a GET request and POST request is that a POST request requires additional information to be sent through the request. This additional information is sent in the body of the post request.


        const xhr = new XMLHttpRequest();
        const url = 'https://api-to-call.com/endpoint';
        const data = JSON.stringify({id: '200'});

        xhr.responseType = 'json';

        xhr.onreadystatechange = () => {
        if(xhr.readyState === XMLHttpRequest.DONE){
            return xhr.response;
        }
        }

        xhr.open('POST', url);
        xhr.send(data);

HTTP REquests with ES6

    



